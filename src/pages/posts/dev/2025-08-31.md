---
layout: ../../../layouts/MarkdownPostLayout.astro
title: Build a Kanban App with Angular and Firebase
pubDate: 2025-08-31
desctiption:
author: roifjcf
tags: ["Tutorial", "Angular"]
---

My first dev blog post!

I used to build apps with React, but this time I wanted to try something new.

I started learning Angular recently, and this CRUD kanban app is my very first Angular project inspired by a [tutorial on Codelabs](https://developers.google.com/codelabs/building-a-web-app-with-angular-and-firebase#9) .

<br />

Before you start:
- This project is built with Angular `v20.2.1`
- [Source code for this tutorial](https://github.com/roifjcf/angular-kanban-tutorial/tree/master/src%20250904)
- This tutorial won’t cover Angular basics. Essential knowledge can be found on https://angular.dev/essentials

---
## Project Init

First, let's initialize the project. Simply install the Angular CLI tool (if you haven't done) then create a new project.
```bash
npm install -g @angular/cli # install CLI tool (globally)
ng new <project-name> # project init
```

Terminal output. I choose SCSS for styling, feel free to pick whatever you like.
```
✔ Which stylesheet format would you like to use? Sass (SCSS)     [ 
https://sass-lang.com/documentation/syntax#scss                ]
✔ Do you want to enable Server-Side Rendering (SSR) and Static Site Generation 
(SSG/Prerendering)? Yes
✔ Do you want to create a 'zoneless' application without zone.js? Yes
✔ Which AI tools do you want to configure with Angular best practices? 
https://angular.dev/ai/develop-with-ai None
...
hint: 	git branch -m <name>
    Successfully initialized git.
```

The project structure should look something like this:
![](./!images/2025-08-31/Pasted%20image%2020250831155105.png)

Next, open the `app.html`, remove everything except the `<router-outlet />` tag - a placeholder that dynamically loads components based on the current route (though we won’t use routing in this tutorial).
![](./!images/2025-08-31/Pasted%20image%2020250831160341.png)

Now run:
```bash
ng serve
```

You should see a blank page on `http://localhost:4200/`. (Port `4200` is Angular’s default dev server.)

---

## Set Up the Kanban App with Local Data

Let's make sure the app works locally before connecting to firebase. We will create a few components inside the `/src/app` folder. 

<br />

We're going to create two components:
- `task`: displays a single task
- `task-group`: a group component that contains several tasks

<br />

Run the following command to create components:
```bash
# ng g c <component-name>
ng g c task
ng g c task-group
```


There're four files inside each component folder:

- `*.html`: for component display
- `*.scss`: for styling
- `*.ts`: for component's logic and class definition
- `*.spec.ts`: for unit test

<br />

---
### Display Tasks

First, define a task interface. Create a new file `type.ts` under `/src` (or any location you prefer):

<br />

`type.ts`
```ts
export interface TaskInterface {
  title: string;
  description: string;
}
```

Then add the following codes for each component (The `class` attribute is for styling purpose).

<br />

`task.ts`
```ts
/** Component for a task */

import { Component, input } from '@angular/core';
import { TaskInterface } from '../../type';

@Component({
  selector: 'app-task',
  imports: [],
  templateUrl: './task.html',
  styleUrl: './task.scss'
})
export class Task {
  task = input<TaskInterface>();
}
```

`task.html`
- Don't forget to put the brackets to invoke the signal!
```html
<div class="task-container">
  <h3>{{task()?.title}}</h3>
  <p>{{task()?.description}}</p>
</div>
```


`task-group.ts`
```ts
/** Component for a group of tasks */
import { Component, input } from '@angular/core';
import { TaskInterface } from '../../type';
import { Task } from '../task/task';

@Component({
  selector: 'app-task-group',
  imports: [Task],
  templateUrl: './task-group.html',
  styleUrl: './task-group.scss'
})
export class TaskGroup {
  taskList = input<TaskInterface[]>([]);
}
```

`task-group.html`
```html
<div class="taskgroup-container">
  @for (task of taskList(); track task) {
    <app-task [task]="task" />
  }
</div>
```

`app.ts`
```ts
import { Component, signal } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { TaskInterface } from '../type';
import { TaskGroup } from './task-group/task-group';

@Component({
  selector: 'app-root',
  imports: [
    RouterOutlet,
    TaskGroup
  ],
  templateUrl: './app.html',
  styleUrl: './app.scss'
})
export class App {
  protected readonly title = signal('angular-kanban-tutorial');

  todoList: TaskInterface[] = [
    { "title": "todo task 1", "description": "todo task 1 description", },
    { "title": "todo task 2", "description": "todo task 2 description", },
    { "title": "todo task 3", "description": "todo task 3 description", }
  ];
  inProgressList: TaskInterface[] = [
    { "title": "in-progress task 1", "description": "in-progress task 1 description", },
    { "title": "in-progress task 2", "description": "in-progress task 2 description", },
  ];
  doneList: TaskInterface[] = [
    { "title": "finished task 1", "description": "finished task 1 description", },
  ];
}
```

`app.html`
```html
<nav>
  <p>Angular kanban tutorial</p>
</nav>

<main>
  <div class="app-task-groups">
    <div>
      <h2>Todo</h2>
      <app-task-group [taskList]="todoList" />
    </div>
    <div>
      <h2>In Progress</h2>
      <app-task-group [taskList]="inProgressList" />
    </div>
    <div>
      <h2>Done</h2>
      <app-task-group [taskList]="doneList" />
    </div>
  </div>
</main>

<router-outlet />
```


A bit styling

`task.scss`
```scss
.task-container {
  padding: 8px;

  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;

  border: 1px solid black;
  border-radius: 4px;
  
  background-color: white;
}
```

`task-group.scss`
```scss
.taskgroup-container {
  gap: 16px;
  display: flex;
  flex-direction: column;
}
```

`app.scss`
```scss
.app-task-groups {
  gap: 24px;
  margin-top: 24px;
  
  display: flex;
  flex-direction: row;
  justify-content: center;
}
```

`styles.scss`
```scss
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  width: 100vw;
  height: 100vh;
}

nav {
  padding: 16px;
  color: #fff;
  background-color: #000;
}
```


The app should look like this at this stage. It's not interactive yet but displays the tasks as expected!

![](./!images/2025-08-31/Pasted%20image%2020250831171915.png)

### Add a Modal for Creating & Editing Tasks

Now let’s make the app interactive. We’ll add a **New Task button** and a modal that lets you **create, edit, or delete tasks**.

<br />

Create a modal component for task editing:
```bash
ng g c task-edit-modal
```

`type.ts`
- The modal handles two status `"new"` and `"edit"`.
```ts
...
export type TaskModalType = "edit" | "new";
```

`task-edit-modal.ts`
- For the "edit" status, in order to load the proper initial value, we use `effect` inside the constructor to update `currTaskTitle` and `currTaskDescription` when the value of `this.currTask()` is updated. (In this case, the parent component will send a new value of `currTask` to the modal component when a `task` component is clicked).
- If you remove the constructor, the input fields will be blank when you open the modal.
```ts
import { Component, computed, effect, input, output } from '@angular/core';
import { TaskInterface, TaskModalType } from '../../type';
import { FormsModule } from '@angular/forms';

@Component({
  selector: 'app-task-edit-modal',
  imports: [FormsModule],
  templateUrl: './task-edit-modal.html',
  styleUrl: './task-edit-modal.scss'
})
export class TaskEditModal {
  mode = input<TaskModalType>("new");
  /** New task */
  newTaskTitle = "";
  newTaskDescription = "";
  /** Existing task */
  currTask = input<TaskInterface>();
  currTaskTitle = this.currTask()?.title;
  currTaskDescription = this.currTask()?.description;
  
  constructor() {
    effect(() => {
      const task = this.currTask();
      if (task) {
        this.currTaskTitle = task.title;
        this.currTaskDescription = task.description;
      }
    });
  }

  closeModalEvent = output<boolean>();
  closeModal() { this.closeModalEvent.emit(false); }
}
```

`task-edit-modal.html`
- In order to make the input value updated properly, we use two-way data binding. Two-way data binding means the bound variable can be changed by the app or the user (e.g. the user types and the input gets changed).
- Let's take `[(ngModel)]="currTaskDescription"` as an example. Its initial value is set to the current value of a task. The value of `currTaskDescription` will be updated if the user types something, so that the app can keep correct input values for upcoming events.
```html
<div class="taskeditmodal-container">
  <div class="fields">
    <label for="taskTitle">
      <p>Title</p>
      @if (mode() === "new") {
        <input
          id="taskTitle"
          type="text"
          [(ngModel)]="newTaskTitle"
        />} @else if (mode() === "edit") {
        <input
          id="taskTitle"
          type="text"
          [(ngModel)]="currTaskTitle"
        />
      }
    </label>
    <label for="taskDescription">
      <p>Description</p>
      @if (mode() === "new") {
        <input
          id="taskDescription"
          type="text"
          [(ngModel)]="newTaskDescription"
        />
      } @else if (mode() === "edit") {
        <input
          id="taskDescription"
          type="text"
          [(ngModel)]="currTaskDescription"
        />
      }
    </label>
  </div>

  <div class="button-group">
    @if (mode() === "new") {
      <button (click)="closeModal()">Cancel</button>
      <button>Add</button>
    } @else if (mode() === "edit") {
      <button>Delete</button>
      <button (click)="closeModal()">Cancel</button>
      <button>Confirm</button>
    }
  </div>

</div>
```


`task.ts`
- Add an output signal to emit the task when the component gets double-clicked.
```ts
import { Component, input, output } from '@angular/core';
...
...
export class Task {
  ...
  showEditTaskModalEvent = output<TaskInterface>();
  showEditTaskModal() {
    this.showEditTaskModalEvent.emit({
      title: this.task()?.title ?? "",
      description: this.task()?.description ?? "",
    });
  }
}
```

`task.html`
```html
<div class="task-container" (dblclick)="showEditTaskModal()">
...
```

`task-group.ts`
- Add an output signal whose name is the same as the signal we just added to `task` component.
-  Then the order of passing the output signal `showEditTaskModalEvent` across components   is gonna be: `task` -> `task-group` -> `app`.
```ts
import { Component, input, output } from '@angular/core';
...
export class TaskGroup {
  ...
  showEditTaskModalEvent = output<TaskInterface>();
  showEditTaskModal(task: TaskInterface) {
    this.showEditTaskModalEvent.emit(task);
  }
}
```

`task-group.html`
```html
...
<app-task
  [task]="task"
  (showEditTaskModalEvent)="showEditTaskModal($event)"
/>
...
```


Finally, update the `app` component

<br />

`app.ts`
- Add some logic for controlling the display of modal.
```ts
...
import { TaskEditModal } from './task-edit-modal/task-edit-modal';
@Component({
  ...
  imports: [
    ...
    TaskEditModal,
  ],
  ...
})
export class App {
  ...
  showModal = false;
  mode: TaskModalType = "new";
  currTaskTitle = "";
  currTaskDescription = "";

  closeModal() {
    this.showModal = false;
  }
  showNewTaskModal() {
    this.showModal = true;
    this.mode = "new";
  }
  showEditTaskModal(task: TaskInterface) {
    this.showModal = true;
    this.mode = "edit";
    this.currTaskTitle = task.title;
    this.currTaskDescription = task.description;
  }
}
```

`app.html`
- Add a button inside the  `<nav>` tag to control the display of the modal.
- Add a few event listeners to `app-task-group` components.
- Of course, add the modal component we just created and related signals.
```html
<nav>
  ...
  <button (click)="showNewTaskModal()">
    + New task
  </button>
</nav>

<main>
  ...
  <app-task-group
    [taskList]="todoList"
    (showEditTaskModalEvent)="showEditTaskModal($event)"
  />
  ...
  <app-task-group
    [taskList]="inProgressList"
    (showEditTaskModalEvent)="showEditTaskModal($event)"
  />
  ...
  <app-task-group
    [taskList]="doneList"
    (showEditTaskModalEvent)="showEditTaskModal($event)"
  />
  ...

  <!-- Modal -->
  @if (showModal) {
    <app-task-edit-modal
      [mode]="mode"
      [currTask]="{title: currTaskTitle, description: currTaskDescription}"
      (closeModalEvent)="closeModal()"
    />
  }
</main>
```


More styling!

<br />

`task-edit-modal.scss`
```scss
.taskeditmodal-container {
  padding: 16px;

  display: flex;
  flex-direction: column;

  position: fixed;
  top: 50%;
  right: 50%;
  transform: translate(50%,-50%);

  border: 1px solid black;
  border-radius: 4px;

  background-color: white;

  .button-group {
    display: flex;
    flex-direction: row;
  }
}
```

`task.scss`
```scss
.task-container {
  ...
  &:hover {
    cursor: pointer;
  }
}
```

![](./!images/2025-08-31/Pasted%20image%2020250831221629.png)

Now the modal is able to handle both `"new"` and `"edit"` status. The value of input fields are shown properly. Moreover, if we click the "cancel" button, the modal will close properly. Now let's make other buttons work as well on click!

<br />

`task-edit-modal.ts`
- Add output signals for events (`add`, `update`, and `delete`).
- Also tweak `currTaskTitle` and `currTaskDescription` so they fallback to empty strings if `this.currTask()` is undefined.
```ts
export class TaskEditModal {
  ...
  currTaskTitle = this.currTask()?.title ?? "";
  currTaskDescription = this.currTask()?.description ?? "";
  ...
  addNewTaskEvent = output<TaskInterface>();
  addNewTask() {
    this.addNewTaskEvent.emit({
      "title": this.newTaskTitle,
      "description": this.newTaskDescription,
    });
    this.closeModal();
  }

  updateTaskEvent = output<TaskInterface>();
  updateTask() {
    this.updateTaskEvent.emit({
      "title": this.currTaskTitle,
      "description": this.currTaskDescription,
    });
    this.closeModal();
  }

  deleteTaskEvent = output<TaskInterface>();
  deleteTask() {
    const task =  this.currTask();
    if (task) {
      this.deleteTaskEvent.emit(task);
    }
    this.closeModal();
  }
}
```

`task-edit-modal.html`
- Update events.
```html
...
<div class="button-group">
  @if (mode() === "new") {
    <button (click)="closeModal()">Cancel</button>
    <button (click)="addNewTask()">Add</button>
  } @else if (mode() === "edit") {
    <button (click)="deleteTask()">Delete</button>
    <button (click)="closeModal()">Cancel</button>
    <button (click)="updateTask()">Confirm</button>
  }
</div>
...
```

`app.ts`
- Add a property `taskToEdit` to keep track of the task being modified.
```ts
export class App {
  ...
  taskToEdit: TaskInterface | undefined;
  ...
  showEditTaskModal(task: TaskInterface) {
    ...
    this.taskToEdit = task;
    ...
  }
  ...
  addNewTask(task: TaskInterface) { this.todoList.push(task); }
  updateTask(task: TaskInterface) {
    const updateList = (list: TaskInterface[]) => 
      list.map(oldTask => oldTask === this.taskToEdit ? {...task} : oldTask);
    
    this.todoList = updateList(this.todoList);
    this.inProgressList = updateList(this.inProgressList);
    this.doneList = updateList(this.doneList);
  }
  deleteTask() {
    this.todoList = this.todoList.filter(oldTask => oldTask !== this.taskToEdit);
    this.inProgressList = this.inProgressList.filter(oldTask => oldTask !== this.taskToEdit);
    this.doneList = this.doneList.filter(oldTask => oldTask !== this.taskToEdit);
  }
  ...
}
```

`app.html`
- Add event handlers for associated events (`add`, `update`, and `delete`).
```html
...
@if (showModal) {
  <app-task-edit-modal
    ...
    (addNewTaskEvent)="addNewTask($event)"
    (updateTaskEvent)="updateTask($event)"
    (deleteTaskEvent)="deleteTask()"
  />
}
...
```

`task.ts`
- Emit the original object instead of creating a new object.
```ts
...
export class Task {
  ...
  showEditTaskModal() {
    const currTask = this.task();
    if (currTask) {
      this.showEditTaskModalEvent.emit(currTask);
    }
  }
  ...
}
```

Now we can add a new task, or edit / delete any existing task as we like. Let's implement the drag and drop feature to update the status (`todo`, `in-progress`, or `done`) of a task!

### Reorder Tasks with Drag & Drop

Next, let’s make tasks draggable between columns (`Todo`, `In Progress`, and `Done`) using Angular’s [CDK drag-drop](https://angular.dev/guide/drag-drop?utm_source=chatgpt.com).

<br />

First install the package
``` bash
ng add @angular/cdk
```


`task.ts`
```ts
...
import { CdkDrag } from '@angular/cdk/drag-drop';
...
@Component({
  ...
  imports: [ CdkDrag ],
  ...
})
...
```

`task.html`
```html
<div
  cdkDrag
  ...
>
...
```

`app.ts`
```ts
...
import { CdkDragDrop, moveItemInArray, transferArrayItem, CdkDropList } from '@angular/cdk/drag-drop';
...
@Component({
  ...
  imports: [
    ...
    CdkDropList
  ],
  ...
})
export class App {
  ...
  drop(event: CdkDragDrop<TaskInterface[]>) {
    // runs when the drop event finished
    if (event.previousContainer === event.container) {
      moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
    } else {
      transferArrayItem(
        event.previousContainer.data,
        event.container.data,
        event.previousIndex,
        event.currentIndex,
      );
    }
  }
}
```

`app.html`
```html
...
<h2>Todo</h2>
<app-task-group
  ...
  cdkDropList
  #cdkTodoList="cdkDropList"
  [cdkDropListData]="todoList"
  [cdkDropListConnectedTo]="[cdkInProgressList, cdkDoneList]"
  (cdkDropListDropped)="drop($event)"
/>
...
<h2>In Progress</h2>
<app-task-group
  ...
  cdkDropList
  #cdkInProgressList="cdkDropList"
  [cdkDropListData]="inProgressList"
  [cdkDropListConnectedTo]="[cdkTodoList, cdkDoneList]"
  (cdkDropListDropped)="drop($event)"
/>
...
<h2>Done</h2>
<app-task-group
  ...
  cdkDropList
  #cdkDoneList="cdkDropList"
  [cdkDropListData]="doneList"
  [cdkDropListConnectedTo]="[cdkTodoList, cdkInProgressList]"
  (cdkDropListDropped)="drop($event)"
/>
...
```


More styling!

`styles.scss`
```scss
...
/* Drag and drop CDK */
.cdk-drag-animating { transition: transform 250ms; }
.cdk-drag-placeholder { opacity: 0; }
```

`task-group.scss`
```scss
.taskgroup-container {
  width: 100%;
  height: 100%;
  ...
}
```


---
## Firebase Integration

So far, everything runs with local data. Let’s connect the app to Firebase to persist tasks.
### Set Up the Firebase Service

Create a Firebase project
![](./!images/2025-08-31/Pasted%20image%2020250901203933.png)
Then go to the homepage of the project you just created, click "Firestore Database" and create a database (standard edition, test mode)

![](./!images/2025-08-31/Pasted%20image%2020250901204157.png)

![](./!images/2025-08-31/Pasted%20image%2020250901204937.png)
Click the "+ Start collection" button, add three collections and related documents. Feel free to use "Auto-ID" for the document id.

I added three collections called `kanban-todo`, `kanban-inprogress`, and `kanban-done`.

For this kanban project, a document represents a task. Each document should have two fields of `string` type - `title` and `description`, to match the interface of `TaskInterface` we defined earlier in `type.ts`

Here's an example:
![](./!images/2025-08-31/Pasted%20image%2020250901205642.png)

You can add more documents by clicking the "Add document" button.
![](./!images/2025-08-31/Pasted%20image%2020250901211059.png)

<br />

Add the `@angular/fire` library to our project. You can find more info on the package release page: https://www.npmjs.com/package/@angular/fire/v/7.2.0
- You will notice that some updates in your project files after running the command, for example, `providers` in `app.config.ts`.
```bash
ng add @angular/fire
```

![](./!images/2025-08-31/Pasted%20image%2020250901204708.png)

Some helpful docs for `@angular/fire` APIs:
- https://github.com/angular/angularfire/blob/main/docs/install-and-setup.md
- https://firebase.google.com/docs/firestore



### Connect the Angular Project to Firebase

Now let's modify our app to make it fetch data from firestore.

<br />

`type.ts`
- Add an id field for firebase document id.
```ts
export interface TaskInterface {
  id?: string; // Firestore document id
  ...
}
```

Add a directory called `services` under `/src`, then create a service file `task.service.ts`

<br />

`task.service.ts`
- Create an inject-able service for manipulating the firestore database.
```ts
import { Injectable, inject } from '@angular/core';
import {
  Firestore,
  collection,
  collectionData,
  addDoc,
  updateDoc,
  deleteDoc,
  doc
} from '@angular/fire/firestore';
import { Observable } from 'rxjs';
import { TaskInterface } from '../type';

@Injectable({ providedIn: 'root' })
export class TaskService {
  private firestore = inject(Firestore);

  private getCollection(name: string) {
    return collection(this.firestore, `kanban-${name}`);
  }

  /** Get tasks as observable */
  getTasks(name: string): Observable<TaskInterface[]> {
    return collectionData(this.getCollection(name), { idField: 'id' }) as Observable<TaskInterface[]>;
  }

  /** Add a new task */
  addTask(name: string, task: TaskInterface) {
    return addDoc(this.getCollection(name), {
      "title": task.title,
      "description": task.description
    });
  }

  /** Update a task */
  updateTask(name: string, task: TaskInterface) {
    if (!task.id) return;
    const ref = doc(this.firestore, `kanban-${name}/${task.id}`);
    return updateDoc(ref, {
      title: task.title,
      description: task.description,
    });
  }

  /** Delete a task */
  deleteTask(name: string, taskId: string) {
    const ref = doc(this.firestore, `kanban-${name}/${taskId}`);
    return deleteDoc(ref);
  }

  /** Moves a task to another collection */
  async moveTask(task: TaskInterface, from: string, to: string) {
    if (!task.id) return;
    // delete from old collection
    const oldTask = {...task};
    const oldRef = doc(this.firestore, `kanban-${from}/${task.id}`);
    deleteDoc(oldRef);

    // add to new collection
    addDoc(this.getCollection(to), {
      "title": oldTask.title,
      "description": oldTask.description,
    });
  }
  
}
```

`app.ts`
- Replace `todoList`, `inProgressList`, and `doneList` with signals.
```ts
import { Component, inject, signal, WritableSignal } from '@angular/core';
...
import { Observable } from 'rxjs';
import { TaskService } from '../services/task.service';
...
export class App {
  ...
  todoList$: Observable<TaskInterface[]>;
  inProgressList$: Observable<TaskInterface[]>;
  doneList$: Observable<TaskInterface[]>;
  todoList = signal<TaskInterface[]>([]);
  inProgressList = signal<TaskInterface[]>([]);
  doneList = signal<TaskInterface[]>([]);

  /** Gets data from firestore */
  constructor(private taskService: TaskService) {
    // subscribe to task streams
    this.todoList$ = this.taskService.getTasks('todo');
    this.inProgressList$ = this.taskService.getTasks('inprogress');
    this.doneList$ = this.taskService.getTasks('done');

    this.todoList$.subscribe(data => this.todoList.set(data));
    this.inProgressList$.subscribe(data => this.inProgressList.set(data));
    this.doneList$.subscribe(data => this.doneList.set(data));
  }
  
  ...
  
  
  // helper to find which collection the task belongs to
  private getCollectionName(task: TaskInterface): string {
    if (this.todoList().filter(t => t.id === task.id).length > 0) return 'todo';
    if (this.inProgressList().filter(t => t.id === task.id).length > 0) return 'inprogress';
    if (this.doneList().filter(t => t.id === task.id).length > 0) return 'done';
    return 'todo'; // fallback
  } 

  

  addNewTask(task: TaskInterface) {
    this.todoList.update(list => [...list, task]);
    this.taskService.addTask('todo', task);
  }

  updateTask(updatedTask: TaskInterface) {
    if (!updatedTask.id) return;
    const col = this.getCollectionName(updatedTask);

    const updateList = (listSignal: WritableSignal<TaskInterface[]>) => {
      listSignal.update(list =>
        list.map(task => task === this.taskToEdit ? { ...updatedTask } : task)
      );
    };

    updateList(this.todoList);
    updateList(this.inProgressList);
    updateList(this.doneList);

    this.taskService.updateTask(col, updatedTask);
  }

  deleteTask() {
    if (!this.taskToEdit?.id) return;
    const col = this.getCollectionName(this.taskToEdit);

    this.todoList.update(list => list.filter(task => task !== this.taskToEdit));
    this.inProgressList.update(list => list.filter(task => task !== this.taskToEdit));
    this.doneList.update(list => list.filter(task => task !== this.taskToEdit));

    this.taskService.deleteTask(col, this.taskToEdit.id);
  }

  private getColumnName(listId: string): string | null {
    if (listId === "cdk-drop-list-0") return 'todo';
    if (listId.includes("cdk-drop-list-1")) return 'inprogress';
    if (listId.includes("cdk-drop-list-2")) return 'done';
    return null;
  }
  
  drop(event: CdkDragDrop<TaskInterface[]>) {
    // runs when the drop event finished
    if (event.previousContainer === event.container) {
      moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
    } else {
      transferArrayItem(
        event.previousContainer.data,
        event.container.data,
        event.previousIndex,
        event.currentIndex,
      );
      // Firestore update
      
      const task = event.container.data[event.currentIndex];
      const from = this.getColumnName(event.previousContainer.id);
      const to = this.getColumnName(event.container.id);
      if (task && from && to && from !== to) {
        this.taskService.moveTask(task, from, to);
      }
    }
  }
}
```


`app.html`
- Invoke the signals...
```html
...
<h2>Todo</h2>
<app-task-group
  [taskList]="todoList()"
  ...
  [cdkDropListData]="todoList()"
  ...
/>
...
<h2>In Progress</h2>
<app-task-group
  [taskList]="inProgressList()"
  ...
  [cdkDropListData]="inProgressList()"
  ...
/>
...
<h2>Done</h2>
<app-task-group
  [taskList]="doneList()"
  ...
  [cdkDropListData]="doneList()"
  ...
/>
...
```


`task-edit-modal.ts`
```ts
export class TaskEditModal {
  ...
  addNewTask() {
    this.addNewTaskEvent.emit({
      "id": this.currTask()?.id,
      ...
    });
    ...
  }
  ...
  updateTask() {
    this.updateTaskEvent.emit({
      "id": this.currTask()?.id,
      ...
    });
    ...
  }
  ...
}
```

`task-group.html`
```html
<div class="taskgroup-container">
  @for (task of taskList(); track task.id) {
    ...
  }
</div>
```

Finally, tweak the style a little bit

`app.scss`
```scss
...
.app-task-groups > div {
  width: 100%;
}
```

![](./!images/2025-08-31/Pasted%20image%2020250902000740.png)

## Summary

That's my approach to build a kanban app with Angular + firebase.

You might see some warning messages in the console when the app connects to Firebase (I haven’t figured those out yet), but aside from that, everything works as expected.
